text = """
1,330,331,332,109,3594,1102,1182,1,15,1102,1,1487,24,1001,0,0,570,1006,570,36,1001,571,0,0,1001,570,-1,570,1001,24,1,24,1106,0,18,1008,571,0,571,1001,15,1,15,1008,15,1487,570,1006,570,14,21102,1,58,0,1106,0,786,1006,332,62,99,21101,0,333,1,21102,73,1,0,1106,0,579,1102,1,0,572,1102,0,1,573,3,574,101,1,573,573,1007,574,65,570,1005,570,151,107,67,574,570,1005,570,151,1001,574,-64,574,1002,574,-1,574,1001,572,1,572,1007,572,11,570,1006,570,165,101,1182,572,127,1001,574,0,0,3,574,101,1,573,573,1008,574,10,570,1005,570,189,1008,574,44,570,1006,570,158,1105,1,81,21101,0,340,1,1106,0,177,21102,1,477,1,1106,0,177,21101,0,514,1,21101,0,176,0,1105,1,579,99,21102,184,1,0,1106,0,579,4,574,104,10,99,1007,573,22,570,1006,570,165,1001,572,0,1182,21102,375,1,1,21102,211,1,0,1106,0,579,21101,1182,11,1,21101,222,0,0,1106,0,979,21101,0,388,1,21102,233,1,0,1105,1,579,21101,1182,22,1,21102,244,1,0,1105,1,979,21102,401,1,1,21102,255,1,0,1106,0,579,21101,1182,33,1,21102,1,266,0,1105,1,979,21102,1,414,1,21101,0,277,0,1106,0,579,3,575,1008,575,89,570,1008,575,121,575,1,575,570,575,3,574,1008,574,10,570,1006,570,291,104,10,21101,1182,0,1,21101,0,313,0,1105,1,622,1005,575,327,1101,1,0,575,21102,327,1,0,1105,1,786,4,438,99,0,1,1,6,77,97,105,110,58,10,33,10,69,120,112,101,99,116,101,100,32,102,117,110,99,116,105,111,110,32,110,97,109,101,32,98,117,116,32,103,111,116,58,32,0,12,70,117,110,99,116,105,111,110,32,65,58,10,12,70,117,110,99,116,105,111,110,32,66,58,10,12,70,117,110,99,116,105,111,110,32,67,58,10,23,67,111,110,116,105,110,117,111,117,115,32,118,105,100,101,111,32,102,101,101,100,63,10,0,37,10,69,120,112,101,99,116,101,100,32,82,44,32,76,44,32,111,114,32,100,105,115,116,97,110,99,101,32,98,117,116,32,103,111,116,58,32,36,10,69,120,112,101,99,116,101,100,32,99,111,109,109,97,32,111,114,32,110,101,119,108,105,110,101,32,98,117,116,32,103,111,116,58,32,43,10,68,101,102,105,110,105,116,105,111,110,115,32,109,97,121,32,98,101,32,97,116,32,109,111,115,116,32,50,48,32,99,104,97,114,97,99,116,101,114,115,33,10,94,62,118,60,0,1,0,-1,-1,0,1,0,0,0,0,0,0,1,12,20,0,109,4,1202,-3,1,587,20101,0,0,-1,22101,1,-3,-3,21102,1,0,-2,2208,-2,-1,570,1005,570,617,2201,-3,-2,609,4,0,21201,-2,1,-2,1106,0,597,109,-4,2106,0,0,109,5,2101,0,-4,630,20101,0,0,-2,22101,1,-4,-4,21102,1,0,-3,2208,-3,-2,570,1005,570,781,2201,-4,-3,653,20102,1,0,-1,1208,-1,-4,570,1005,570,709,1208,-1,-5,570,1005,570,734,1207,-1,0,570,1005,570,759,1206,-1,774,1001,578,562,684,1,0,576,576,1001,578,566,692,1,0,577,577,21101,0,702,0,1106,0,786,21201,-1,-1,-1,1105,1,676,1001,578,1,578,1008,578,4,570,1006,570,724,1001,578,-4,578,21102,1,731,0,1105,1,786,1106,0,774,1001,578,-1,578,1008,578,-1,570,1006,570,749,1001,578,4,578,21101,0,756,0,1106,0,786,1105,1,774,21202,-1,-11,1,22101,1182,1,1,21101,0,774,0,1106,0,622,21201,-3,1,-3,1106,0,640,109,-5,2105,1,0,109,7,1005,575,802,21001,576,0,-6,20102,1,577,-5,1105,1,814,21101,0,0,-1,21101,0,0,-5,21102,1,0,-6,20208,-6,576,-2,208,-5,577,570,22002,570,-2,-2,21202,-5,49,-3,22201,-6,-3,-3,22101,1487,-3,-3,1202,-3,1,843,1005,0,863,21202,-2,42,-4,22101,46,-4,-4,1206,-2,924,21101,1,0,-1,1106,0,924,1205,-2,873,21102,35,1,-4,1105,1,924,1202,-3,1,878,1008,0,1,570,1006,570,916,1001,374,1,374,1202,-3,1,895,1102,1,2,0,1201,-3,0,902,1001,438,0,438,2202,-6,-5,570,1,570,374,570,1,570,438,438,1001,578,558,922,20101,0,0,-4,1006,575,959,204,-4,22101,1,-6,-6,1208,-6,49,570,1006,570,814,104,10,22101,1,-5,-5,1208,-5,43,570,1006,570,810,104,10,1206,-1,974,99,1206,-1,974,1102,1,1,575,21101,973,0,0,1106,0,786,99,109,-7,2106,0,0,109,6,21102,0,1,-4,21101,0,0,-3,203,-2,22101,1,-3,-3,21208,-2,82,-1,1205,-1,1030,21208,-2,76,-1,1205,-1,1037,21207,-2,48,-1,1205,-1,1124,22107,57,-2,-1,1205,-1,1124,21201,-2,-48,-2,1105,1,1041,21102,1,-4,-2,1105,1,1041,21102,1,-5,-2,21201,-4,1,-4,21207,-4,11,-1,1206,-1,1138,2201,-5,-4,1059,1202,-2,1,0,203,-2,22101,1,-3,-3,21207,-2,48,-1,1205,-1,1107,22107,57,-2,-1,1205,-1,1107,21201,-2,-48,-2,2201,-5,-4,1090,20102,10,0,-1,22201,-2,-1,-2,2201,-5,-4,1103,2102,1,-2,0,1105,1,1060,21208,-2,10,-1,1205,-1,1162,21208,-2,44,-1,1206,-1,1131,1105,1,989,21101,439,0,1,1105,1,1150,21101,477,0,1,1105,1,1150,21101,0,514,1,21101,0,1149,0,1105,1,579,99,21102,1,1157,0,1106,0,579,204,-2,104,10,99,21207,-3,22,-1,1206,-1,1138,1202,-5,1,1176,2102,1,-4,0,109,-6,2105,1,0,14,9,40,1,7,1,40,1,7,1,40,1,7,1,40,1,7,1,40,1,7,1,40,1,7,1,40,1,7,1,40,1,3,5,1,7,5,13,14,1,3,1,5,1,5,1,5,1,11,1,14,1,3,1,5,1,5,1,5,1,11,1,14,1,3,1,5,1,5,1,5,1,11,1,14,7,3,1,3,13,7,1,18,1,1,1,3,1,3,1,1,1,5,1,3,1,7,1,18,1,1,1,3,13,3,1,7,1,18,1,1,1,7,1,1,1,9,1,7,1,18,1,1,1,7,1,1,1,9,9,18,1,1,1,7,1,1,1,32,13,1,1,1,1,3,7,22,1,3,1,1,1,5,1,1,1,1,1,3,1,5,1,8,13,1,1,3,13,3,1,5,1,8,1,13,1,5,1,5,1,1,1,5,1,5,1,8,1,13,1,5,1,5,1,1,1,5,1,5,1,8,1,13,1,5,1,5,1,1,1,5,1,5,1,8,1,13,7,5,1,1,13,8,1,25,1,7,1,14,1,5,9,11,1,7,1,14,1,5,1,7,1,11,1,7,1,14,1,5,1,7,1,11,1,7,1,14,1,5,1,7,1,11,1,7,1,14,1,5,1,7,13,7,7,8,1,5,1,33,1,8,7,33,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,40,9,8
""".strip()


import re
import numpy as np
from collections import deque


class Computer:
    num_parameters = {
        99: 0,
        1: 3, 
        2: 3, 
        3: 1, 
        4: 1,
        5: 2,
        6: 2,
        7: 3,
        8: 3,
        9: 1,
    }
    
    def __init__(self, program, memory_size=10000):
        self.memory = list(program).copy() + [0] * (memory_size - len(program))
        self.instruction_pointer = 0
        self.relative_base = 0
        self.inputs = deque()
        self.outputs = deque()
        
    def add_inputs(self, inputs):
        try:
            iter(inputs)
        except:
            inputs = [inputs]
        self.inputs.extend(inputs)
        return self
    
    def pop_output(self):
        return self.outputs.popleft()
    
    def interpret_indices(self, nparam, modes):
        indices = []
        for k in range(nparam):
            if modes[k] == 0:
                indices.append(self.memory[self.instruction_pointer+k+1])
            elif modes[k] == 1:
                indices.append(self.instruction_pointer+k+1)
            elif modes[k] == 2:
                indices.append(self.memory[self.instruction_pointer+k+1] + self.relative_base)
        return indices
    
    def apply_instruction(self, opcode, indices, nparam, wait_for_input):
        increase_pointer = True
        
        if opcode == 99:
            return True
        elif opcode == 1:
            self.memory[indices[2]] = self.memory[indices[1]] + self.memory[indices[0]]
        elif opcode == 2:
            self.memory[indices[2]] = self.memory[indices[1]] * self.memory[indices[0]]
        elif opcode == 3:
            try:
                self.memory[indices[0]] = self.inputs.popleft()
            except IndexError as e:
                if wait_for_input:
                    return True
                raise e
        elif opcode == 4:
            self.outputs.append(self.memory[indices[0]])
        elif opcode == 5:
            if self.memory[indices[0]] != 0:
                self.instruction_pointer = self.memory[indices[1]]
                increase_pointer = False
        elif opcode == 6:
            if self.memory[indices[0]] == 0:
                self.instruction_pointer = self.memory[indices[1]]
                increase_pointer = False
        elif opcode == 7:
            self.memory[indices[2]] = 1 if self.memory[indices[0]] < self.memory[indices[1]] else 0
        elif opcode == 8:
            self.memory[indices[2]] = 1 if self.memory[indices[0]] == self.memory[indices[1]] else 0
        elif opcode == 9:
            self.relative_base += self.memory[indices[0]]

        if increase_pointer:
            self.instruction_pointer += nparam+1
        return False
        
    def run(self, n_outputs=np.inf, wait_for_input=False):
        halt = False
        while not halt:
            instruction = "%05d" % self.memory[self.instruction_pointer]
            opcode = int(instruction[3:])
            nparam = self.num_parameters[opcode]
            modes = [int(x) for x in list(instruction[:3])[::-1]]
            indices = self.interpret_indices(nparam, modes)
            halt = self.apply_instruction(opcode, indices, nparam, wait_for_input)
            if len(self.outputs) >= n_outputs:
                break
        return halt


# 1
def adjacent_positions(i, j):
    return [(i, j+1), (i, j-1), (i+1, j), (i-1, j)]


def read_image(computer):
    image = np.array([chr(x) for x in computer.outputs])[:-1]
    width = (image == '\n').argmax() + 1
    return image.reshape(-1, width)[:, :-1]


program = [int(x) for x in text.split(',')]
computer = Computer(program)
computer.run()
image = read_image(computer)

intersections = []
for i, j in zip(*np.where(image == '#')):
    is_intersect = True
    for i2, j2 in adjacent_positions(i, j):
        if i2 < 0 or j2 < 0 or i2 >= image.shape[0] or j2 >= image.shape[1] or image[i2, j2] != '#':
            is_intersect = False
    if is_intersect:
        intersections.append((i, j))

score = 0
for i, j in intersections:
    score += i * j
print(score)


# 2
class Direction:
    UP = '^'
    RIGHT = '>'
    DOWN = 'v'
    LEFT = '<'
    LIST = [UP, RIGHT, DOWN, LEFT]

    
class Turn:
    LEFT = 'L'
    RIGHT = 'R'
    
    
def valid_adjacent_positions(direction, i, j, image):
    positions = []
    if direction in [Direction.UP, Direction.DOWN]:
        if j < image.shape[1]-1:
            positions.append((i, j+1))
        if j > 0:
            positions.append((i, j-1))
    else:
        if i < image.shape[0]-1:
            positions.append((i+1, j))
        if i > 0:
            positions.append((i-1, j))
    return positions


def next_turn(direction, i1, j1, i2, j2):
    if direction == Direction.UP:
        if j2 < j1:
            return Turn.LEFT
        else:
            return Turn.RIGHT
    if direction == Direction.RIGHT:
        if i2 < i1:
            return Turn.LEFT
        else:
            return Turn.RIGHT
    if direction == Direction.DOWN:
        if j2 < j1:
            return Turn.RIGHT
        else:
            return Turn.LEFT
    if direction == Direction.LEFT:
        if i2 < i1:
            return Turn.RIGHT
        else:
            return Turn.LEFT
        
        
def next_direction(direction, turn):
    if direction == Direction.UP:
        if turn == Turn.LEFT:
            return Direction.LEFT
        else:
            return Direction.RIGHT
    if direction == Direction.RIGHT:
        if turn == Turn.LEFT:
            return Direction.UP
        else:
            return Direction.DOWN
    if direction == Direction.DOWN:
        if turn == Turn.LEFT:
            return Direction.RIGHT
        else:
            return Direction.LEFT
    if direction == Direction.LEFT:
        if turn == Turn.LEFT:
            return Direction.DOWN
        else:
            return Direction.UP
        
        
def next_position(direction, i, j, steps=1):
    if direction == Direction.UP:
        return i-steps, j
    if direction == Direction.RIGHT:
        return i, j+steps
    if direction == Direction.DOWN:
        return i+steps, j
    if direction == Direction.LEFT:
        return i, j-steps
    
    
def is_valid_position(i, j, image):
    return i >= 0 and j >= 0 and i <= image.shape[0]-1 and j <= image.shape[1]-1


def multi_subsequences(strings, max_size):
    def subsequences(string, max_size):
        all_results = []
        for size in range(max_size, 0, -1):
            results = []
            for start in range(0, len(string)-size+1):
                if ((start == 0 or string[start-1] == ',')
                    and (start+size == len(string) or string[start+size] == ',')
                    and (string[start] in [Turn.LEFT, Turn.RIGHT])
                    and (string[start+size-1].isnumeric())
                   ):
                    results.append(string[start:start+size])
            all_results.extend(results)
        return all_results
    
    return sorted(set().union(*(subsequences(s, max_size) for s in strings)), key=len, reverse=True)


def split_sequences(sequences, pattern_history=None, layer=0, max_size=20, max_layers=3):
    if pattern_history is None:
        pattern_history = []
    if len(sequences) == 0:
        return pattern_history
    if layer >= max_layers:
        return
    for pattern in multi_subsequences(sequences, max_size):
        new_sequences = [re.sub('(^,|,$)', '', t) for s in sequences for t in re.sub(pattern, ' ', s).split()]
        new_sequences = [s for s in new_sequences if s]
        result = split_sequences(new_sequences, pattern_history + [pattern], layer+1)
        if result is not None:
            return result

        
def to_ascii_input(line):
    return [int(x) for x in ' '.join(str(ord(x)) for x in line).split(' ')]


i, j = [int(x) for x in np.where(np.isin(image, Direction.LIST))]
direction = image[i, j]
sequence = []

while True:
    found_next = False
    for i2, j2 in valid_adjacent_positions(direction, i, j, image):
        if image[i2, j2] == '#':
            found_next = True
            break
    if not found_next:
        break

    turn = next_turn(direction, i, j, i2, j2)
    direction = next_direction(direction, turn)

    forward = 0
    i2, j2 = i, j
    while True:
        i2, j2 = next_position(direction, i2, j2)
        if not is_valid_position(i2, j2, image) or image[i2, j2] != '#':
            break
        forward += 1
    
    i, j = next_position(direction, i, j, steps=forward)
    sequence.append(turn + ',' + str(forward))
sequence = ','.join(sequence)

functions = {i: f for i, f in enumerate(['A', 'B', 'C'])}
patterns = split_sequences([sequence])
routine = []
for match in re.finditer('(' + '|'.join(patterns) + ')', sequence):
    routine.append(functions[patterns.index(match.group())])
routine = ','.join(routine)

program = [int(x) for x in text.split(',')]
program[0] = 2
computer = Computer(program)

input_list = '\n'.join([routine] + patterns + ['n,\n'])
computer.add_inputs(to_ascii_input(input_list))
computer.run()
print(computer.outputs[-1])
